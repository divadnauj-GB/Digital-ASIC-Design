# Makefiles for verilog simulations
Makefile commands are instructions executed by the make utility to build or manage projects. These commands are defined within a Makefile and are associated with specific targets.

## Key Concepts:

### Targets:
These represent files to be created or actions to be performed (e.g., `all`, `clean`, `program`).
### Dependencies:
Files or other targets that a target relies on. If a dependency is newer than the target, or if the target doesn't exist, `make` will execute the associated commands.
### Commands:
Shell commands that `make` executes to build a target or perform an action. Each command line in a rule must begin with a tab character. 

### Makefile Syntax
```Makefile
targets: prerequisites
	command
	command
	command
```

## Common Makefile Commands/Targets and their Purpose:
`make`: When executed without a specific target, `make` will build the first target defined in the Makefile (often named `all`).

`make [target_name]`: Executes the commands associated with the specified `target_name`.

`make clean`: A common target used to remove generated files (object files, executables, temporary files) from a project, ensuring a clean build environment.

`make install`: Installs the built project files into a designated location.

`make test`: Runs tests defined within the project.

# Tutorial makefiles 
This tutorial walks you trough the steps for compilation, simulation and visualization of verilog HDL designs. 

## Basic Intro to Icarus simulation

Icarus Verilog is a Verilog HDL compiler and simulator. Its usage primarily involves two main commands: iverilog for compilation and vvp for simulation.

### 1. iverilog (Compiler Command):
This command compiles your Verilog source files into an intermediate format, typically a .vvp file, which is then executed by the vvp runtime engine. Basic Compilation.


```bash 
iverilog -o <output_filename>.vvp <source_file1>.v <source_file2>.v ...
```

`-o <output_filename>.vvp`: Specifies the name of the compiled output file.

`<source_file>.v`: Your Verilog source code files.

#### Common Flags:
`-c <cmdfile>`: Specifies a command file containing compilation options.

`-D <macro_name>[=<value>]`: Defines a macro, similar to #define in C.

`-g <generation_flag>`: Specifies the Verilog language standard or extensions to use (e.g., `-g2005-sv` for SystemVerilog features).

`-I <path>`: Adds a directory to the include file search path.

`-M <mode>=<path>`: Sets a specific mode for VPI (Verilog Procedural Interface) modules.

`-m <module>`: Loads a VPI module.

`-y <library_path>`: Specifies a library directory to search for modules.

`-Wall`: Enables all warnings during compilation.

### 2. vvp (Simulator Command):
This command executes the compiled .vvp file generated by iverilog to run the simulation. Basic Simulation.

```bash
vvp <compiled_filename>.vvp # alternativelly you can run ./<compiled_filename>.vvp 
```

`<compiled_filename>.vvp`: The output file from iverilog.

#### Common Flags:
`+<plus_arg>`: Passes extended arguments to the simulation, accessible through $test$plusargs and $value$plusargs system functions in your Verilog code.

`-lxt2, -fst, etc.`: Specifies the waveform dumping format (e.g., for use with GTKWave).

`-o <dump_filename>.vcd`: Specifies the output file for waveform dumps (e.g., VCD format).

## Example Workflow:
Write your Verilog code: Create a file like my_design.v and my_testbench.v.

Compile:
```bash
iverilog -o my_simulation.vvp my_design.v my_testbench.v
```
Simulate and generate waveform.
```bash
vvp -lxt2 -o my_waveform.vcd my_simulation.vvp
```
View waveform (e.g., with GTKWave):

```bash
gtkwave my_waveform.vcd
```

Note: For more information about the usage of iverilog you can check this link https://steveicarus.github.io/iverilog/ 

## Makefile tutorial for icarus

In this tutorial we are going to create a Makefile for the RGB mixer introducen in the previous tutorial. 

In the first place, lets create a file named `Makefile`the the `./Digital-ASIC-Design/Tutorial/2.1Makefile_tutorial` as follows:

```bash
cd ./Digital-ASIC-Design/Tutorial/2.1Makefile_tutorial
touch Makefile
```

Edit the file in order to include the first make rule to compile and simulate the PWM module. 

```Makefile
test_pwm: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_PWM.vvp -s tb_PWM src/PWM.v tb/tb_PWM.v 
	./sim_build/tb_PWM.vvp
	! grep failure results.xml
```

This makefile target automatically performs the following acctions. 

- It delets de `sim_build` directory and all its content, and creates a new empty `sim_build`directory. This directory is used for keeping all simulation and generated files organized. 
- Compiles the verilog files using icarus
- Executes the simulation using the generated *.vvp simulation file 
- Dump into an xml file any simulation failure specified in the testbench.

### How to execute the simulation?

The simulation can be executed by simply typing in the terminal the following command: 

```bash
make test_pwm
```

Now, let's complete the rest of make rules for the rest of the modules in the RGB mixer example. 

```Makefile
test_pwm: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_PWM.vvp -s tb_PWM src/PWM.v tb/tb_PWM.v 
	./sim_build/tb_PWM.vvp
	! grep failure results.xml

test_debounce: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_debounce.vvp -s tb_debounce src/debounce.v tb/tb_debounce.v 
	./sim_build/tb_debounce.vvp
	! grep failure results.xml

test_edge_detector: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_edge_detector.vvp -s tb_edge_detector src/edge_detector.v tb/tb_edge_detector.v 
	./sim_build/tb_edge_detector.vvp
	! grep failure results.xml

test_up_down_counter: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_up_down_counter.vvp -s tb_up_down_counter src/up_down_counter.v tb/tb_up_down_counter.v 
	./sim_build/tb_up_down_counter.vvp
	! grep failure results.xml

test_rgb_mixer: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_rgb_mixer.vvp -s tb_rgb_mixer src/*.v tb/tb_rgb_mixer.v 
	./sim_build/tb_rgb_mixer.vvp
	! grep failure results.xml
```

In this way, you can automatically execute a simulation of multiple or single designs by simply typing the make command. In this way it is not necesary to manually execute the whole command, instead you just execute `make`and the desired target. 

It is also useful to execute all target under the `all`target as shown below.

```Makefile
all: test_pwm test_debounce  test_edge_detector test_up_down_counter test_rgb_mixer

test_pwm: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_PWM.vvp -s tb_PWM src/PWM.v tb/tb_PWM.v 
	./sim_build/tb_PWM.vvp
	! grep failure results.xml

test_debounce: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_debounce.vvp -s tb_debounce src/debounce.v tb/tb_debounce.v 
	./sim_build/tb_debounce.vvp
	! grep failure results.xml

test_edge_detector: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_edge_detector.vvp -s tb_edge_detector src/edge_detector.v tb/tb_edge_detector.v 
	./sim_build/tb_edge_detector.vvp
	! grep failure results.xml

test_up_down_counter: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_up_down_counter.vvp -s tb_up_down_counter src/up_down_counter.v tb/tb_up_down_counter.v 
	./sim_build/tb_up_down_counter.vvp
	! grep failure results.xml

test_rgb_mixer: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_rgb_mixer.vvp -s tb_rgb_mixer src/*.v tb/tb_rgb_mixer.v 
	./sim_build/tb_rgb_mixer.vvp
	! grep failure results.xml
```

In this case, when running in the terminal `make all` it automatically will execute all individual simulation automatically. 

### How to visualize waveforms?

In the previous tutorial we used `gtkwave`to visualize the `VCD`files, which contain the behaviour of the module. Intead of running manually such sommand every time, it is possible to asociate a `make target` with the waveform visualization at the end of the makefile. 

```Makefile
all: test_pwm test_debounce  test_edge_detector test_up_down_counter test_rgb_mixer

test_pwm: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_PWM.vvp -s tb_PWM src/PWM.v tb/tb_PWM.v 
	./sim_build/tb_PWM.vvp
	! grep failure results.xml

test_debounce: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_debounce.vvp -s tb_debounce src/debounce.v tb/tb_debounce.v 
	./sim_build/tb_debounce.vvp
	! grep failure results.xml

test_edge_detector: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_edge_detector.vvp -s tb_edge_detector src/edge_detector.v tb/tb_edge_detector.v 
	./sim_build/tb_edge_detector.vvp
	! grep failure results.xml

test_up_down_counter: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_up_down_counter.vvp -s tb_up_down_counter src/up_down_counter.v tb/tb_up_down_counter.v 
	./sim_build/tb_up_down_counter.vvp
	! grep failure results.xml

test_rgb_mixer: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_rgb_mixer.vvp -s tb_rgb_mixer src/*.v tb/tb_rgb_mixer.v 
	./sim_build/tb_rgb_mixer.vvp
	! grep failure results.xml


show_%: %.vcd tb/%.gtkw
	gtkwave $^
```

#### What do the % and $^ symbols mean?

% is a makefile internal wildcard which will serve as a placeholder in a for-each manner. In this case, we can specify any text after `show_` and `make`will try to match that text in the prerequisites. 

On the other hand, ($^) means all prerequisites of the target. 

For example we can open the PWM waveform with this target by executing the following command:

```bash
make show_tb_PWM
```

In this case the make resolves the previous rule into the following one automatically. 

```Makefile
show_tb_PWM: tb_PWM.vcd tb/tb_PWM.gtkw
	gtkwave tb_PWM.vcd tb/tb_PWM.gtkw
```

### How to clean all generated files?
Sometimes after compiling and simulating several times, it is possible to generate quite a lot number of files. In that case, the `Makefile` can help to clean up the working directory. 

In this case you need to add the following command at the end of the Makefile. 

```Makefile
all: test_pwm test_debounce  test_edge_detector test_up_down_counter test_rgb_mixer

test_pwm: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_PWM.vvp -s tb_PWM src/PWM.v tb/tb_PWM.v 
	./sim_build/tb_PWM.vvp
	! grep failure results.xml

test_debounce: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_debounce.vvp -s tb_debounce src/debounce.v tb/tb_debounce.v 
	./sim_build/tb_debounce.vvp
	! grep failure results.xml

test_edge_detector: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_edge_detector.vvp -s tb_edge_detector src/edge_detector.v tb/tb_edge_detector.v 
	./sim_build/tb_edge_detector.vvp
	! grep failure results.xml

test_up_down_counter: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_up_down_counter.vvp -s tb_up_down_counter src/up_down_counter.v tb/tb_up_down_counter.v 
	./sim_build/tb_up_down_counter.vvp
	! grep failure results.xml

test_rgb_mixer: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_rgb_mixer.vvp -s tb_rgb_mixer src/*.v tb/tb_rgb_mixer.v 
	./sim_build/tb_rgb_mixer.vvp
	! grep failure results.xml

show_%: %.vcd tb/%.gtkw
	gtkwave $^

clean: 
	rm *vcd -rf sim_build
```

This make recipe indicates to execute automatically the deletion of any file with the `VCD`extention, and also remove the `sim_build` directory and all its contents. Of course you can add or remove more recipies form the Makefile. 

### Summary

A Makefile contains all recipies used for automating any flow that involves compilation, simulation ecc. 

```bash
make test_rgb_mixer #executes a single recipe
make all # execute the simulation for all modules
make show_tb_edge_detector # open the waverform for tb_edge_detector
make clean #clean up all generated files
```

## Basic Intro to Verilator 
Verilator is a tool that converts Verilog/SystemVerilog code into C++/SystemC code, which can then be compiled and simulated for high-performance verification. The primary command for using Verilator is verilator itself, along with various options and arguments to control its behavior.

### Key verilator commands and options:
`verilator [options] <input_files.v>`:
This is the basic usage, where `input_files.v` are your Verilog/SystemVerilog source files.

### Output Generation Options:
`--cc`: Generates C++ output files.

`--sc`: Generates SystemC output files.

`--binary`: Generates a self-contained executable directly (compiles the generated C++).

`--lint-only`: Performs linting (syntax and style checking) without generating any output code.

`--xml-only`: Generates an XML representation of the design.

### Tracing and Debugging:
`--trace`: Enables waveform generation (VCD format by default).

`--trace-fst`: Enables FST waveform generation (a more efficient format).

`--trace-depth <levels>`: Specifies the hierarchy depth for tracing.

`--debug`: Enables various internal debugging features and messages.

### Input and Include Paths:
`-y <dir>`: Adds a directory to the search path for include files and libraries.

`+incdir+<dir>`: Another way to specify include directories.

`-I<dir>`: Similar to +incdir, for GCC compatibility.

### Module and Top-Level Control:
`--top-module <topname>`: Specifies the top-level module if it's not the same as the input filename.

`--prefix <topname>`: Sets the prefix for generated filenames and class names.

### Language Features and Compliance:
`-sv`: Enables SystemVerilog parsing.

`--timescale <timescale>`: Sets the default timescale for modules without a timescale directive.

### Warnings and Error Handling:
`-Wall`: Enables all style warnings.

`-Wno-<message>`: Disables a specific warning.

`-Werror-<message>`: Converts a specific warning into an error.
Performance and Optimization:

`--threads <threads>`: Enables multithreaded compilation and simulation.

`--savable`: Enables saving and restoring the simulation state.

### Example Usage:

```bash
verilator --cc --trace --top-module my_design my_design.sv
```
This command would generate C++ code for my_design.sv, enable VCD tracing, and specify my_design as the top-level module. After this, you would typically compile the generated C++ code and link it with a C++ testbench to create an executable for simulation.

Note: More information regarding veriltaror and its command line arguments please refer to https://veripool.org/guide/latest/exe_verilator.html 

## Makefile tutorial for Verilator
You will notice that the makefile is very close to the previous example, whit the difference that now we are using Verilator specific commands. 

Let's first create a new Makefile for the RGB mixer. 

In the first place, lets create a file named `Makefile`the the `./Digital-ASIC-Design/Tutorial/2.1Makefile_tutorial` as follows:

```bash
cd ./Digital-ASIC-Design/Tutorial/2.1Makefile_tutorial
touch Makefile
```

Edit the file in order to include the first make rule to compile and simulate the PWM module. 

```Makefile
test_pwm: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal src/PWM.v tb/tb_PWM.v -top-module tb_PWM
	./obj_dir/Vtb_PWM
	! grep failure results.xml
```

This makefile target automatically performs the following acctions. 

- It delets de `obj_dir` directory and all its content. This directory is automatically generated by Verilator for keeping all simulation and generated files organized. 
- Compiles the verilog files using Verilator commands as just explained.
- Executes the simulation using the generated executable under `./obj_dir/`
- Dump into an xml file any simulation failure specified in the testbench.

### How to execute the simulation?

The simulation can be executed by simply typing in the terminal the following command: 

```bash
make test_pwm
```

Now, let's complete the rest of make rules for the rest of the modules in the RGB mixer example. 

```Makefile
test_pwm_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal src/PWM.v tb/tb_PWM.v -top-module tb_PWM
	./obj_dir/Vtb_PWM
	! grep failure results.xml

test_debounce_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal src/debounce.v tb/tb_debounce.v -top-module tb_debounce
	./obj_dir/Vtb_debounce
	! grep failure results.xml

test_edge_detector_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/edge_detector.v tb/tb_edge_detector.v -top-module tb_edge_detector
	./obj_dir/Vtb_edge_detector
	! grep failure results.xml

test_up_down_counter_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/up_down_counter.v tb/tb_up_down_counter.v -top-module tb_up_down_counter
	./obj_dir/Vtb_up_down_counter
	! grep failure results.xml


test_rgb_mixer_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/*.v tb/tb_rgb_mixer.v -top-module tb_rgb_mixer
	./obj_dir/Vtb_rgb_mixer
	! grep failure results.xml
```

In this way, you can automatically execute a simulation of multiple or single designs by simply typing the make command. In this way it is not necesary to manually execute the whole command, instead you just execute `make`and the desired target. 

It is also useful to execute all target under the `all`target as shown below.

```Makefile
all: test_pwm test_debounce  test_edge_detector test_up_down_counter test_rgb_mixer

test_pwm_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal src/PWM.v tb/tb_PWM.v -top-module tb_PWM
	./obj_dir/Vtb_PWM
	! grep failure results.xml

test_debounce_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal src/debounce.v tb/tb_debounce.v -top-module tb_debounce
	./obj_dir/Vtb_debounce
	! grep failure results.xml

test_edge_detector_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/edge_detector.v tb/tb_edge_detector.v -top-module tb_edge_detector
	./obj_dir/Vtb_edge_detector
	! grep failure results.xml

test_up_down_counter_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/up_down_counter.v tb/tb_up_down_counter.v -top-module tb_up_down_counter
	./obj_dir/Vtb_up_down_counter
	! grep failure results.xml


test_rgb_mixer_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/*.v tb/tb_rgb_mixer.v -top-module tb_rgb_mixer
	./obj_dir/Vtb_rgb_mixer
	! grep failure results.xml
```

In this case, when running in the terminal `make all` it automatically will execute all individual simulation automatically. 

### How to visualize waveforms?

In the previous tutorial we used `gtkwave`to visualize the `VCD`files, which contain the behaviour of the module. Intead of running manually such sommand every time, it is possible to asociate a `make target` with the waveform visualization at the end of the makefile. 

```Makefile
all: test_pwm test_debounce  test_edge_detector test_up_down_counter test_rgb_mixer

test_pwm_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal src/PWM.v tb/tb_PWM.v -top-module tb_PWM
	./obj_dir/Vtb_PWM
	! grep failure results.xml

test_debounce_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal src/debounce.v tb/tb_debounce.v -top-module tb_debounce
	./obj_dir/Vtb_debounce
	! grep failure results.xml

test_edge_detector_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/edge_detector.v tb/tb_edge_detector.v -top-module tb_edge_detector
	./obj_dir/Vtb_edge_detector
	! grep failure results.xml

test_up_down_counter_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/up_down_counter.v tb/tb_up_down_counter.v -top-module tb_up_down_counter
	./obj_dir/Vtb_up_down_counter
	! grep failure results.xml


test_rgb_mixer_: 
	rm -rf obj_dir/
	verilator --trace --timing --binary -Wno-moddup -Wno-fatal  src/*.v tb/tb_rgb_mixer.v -top-module tb_rgb_mixer
	./obj_dir/Vtb_rgb_mixer
	! grep failure results.xml


show_%: %.vcd tb/%.gtkw
	gtkwave $^
```

#### What do the % and $^ symbols mean?

% is a makefile internal wildcard which will serve as a placeholder in a for-each manner. In this case, we can specify any text after `show_` and `make`will try to match that text in the prerequisites. 

On the other hand, ($^) means all prerequisites of the target. 

For example we can open the PWM waveform with this target by executing the following command:

```bash
make show_tb_PWM
```

In this case the make resolves the previous rule into the following one automatically. 

```Makefile
show_tb_PWM: tb_PWM.vcd tb/tb_PWM.gtkw
	gtkwave tb_PWM.vcd tb/tb_PWM.gtkw
```

### How to clean all generated files?
Sometimes after compiling and simulating several times, it is possible to generate quite a lot number of files. In that case, the `Makefile` can help to clean up the working directory. 

In this case you need to add the following command at the end of the Makefile. 

```Makefile
all: test_pwm test_debounce  test_edge_detector test_up_down_counter test_rgb_mixer

test_pwm: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_PWM.vvp -s tb_PWM src/PWM.v tb/tb_PWM.v 
	./sim_build/tb_PWM.vvp
	! grep failure results.xml

test_debounce: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_debounce.vvp -s tb_debounce src/debounce.v tb/tb_debounce.v 
	./sim_build/tb_debounce.vvp
	! grep failure results.xml

test_edge_detector: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_edge_detector.vvp -s tb_edge_detector src/edge_detector.v tb/tb_edge_detector.v 
	./sim_build/tb_edge_detector.vvp
	! grep failure results.xml

test_up_down_counter: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_up_down_counter.vvp -s tb_up_down_counter src/up_down_counter.v tb/tb_up_down_counter.v 
	./sim_build/tb_up_down_counter.vvp
	! grep failure results.xml

test_rgb_mixer: 
	rm -rf sim_build/; mkdir sim_build/
	iverilog -o sim_build/tb_rgb_mixer.vvp -s tb_rgb_mixer src/*.v tb/tb_rgb_mixer.v 
	./sim_build/tb_rgb_mixer.vvp
	! grep failure results.xml

show_%: %.vcd tb/%.gtkw
	gtkwave $^

clean: 
	rm *vcd -rf obj_dir
```

This make recipe indicates to execute automatically the deletion of any file with the `VCD`extention, and also remove the `obj_dir` directory and all its contents. Of course you can add or remove more recipies form the Makefile. 

### Summary

A Makefile contains all recipies used for automating any flow that involves compilation, simulation ecc. 

```bash
make test_rgb_mixer #executes a single recipe
make all # execute the simulation for all modules
make show_tb_edge_detector # open the waverform for tb_edge_detector
make clean #clean up all generated files
```

## Conclusion
If you reached to this point, Contratulations!, now you are reay to start the next tutorial.