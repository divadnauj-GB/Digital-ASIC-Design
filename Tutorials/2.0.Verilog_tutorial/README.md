# Verilog tutorial

This tutorial introduces the basics of Verilog HDL for describing digital circuits. In this example we are going to implement a simple RGB color mixer using verilog. 

## RGB mixer example

Before actually write any verilog code for our design, first we need to design the general architecture based on some specifications. An RGB mixer is a circuit that generates tree digital signals to control the brighness of three LEDs (i.e., RED, GREEN, and BLUE) such that the mix of all LEDs intensity create any visible color. In this [link](https://www.youtube.com/watch?v=gA4Q2K62ips) you can find an interesting explanation about how an RGB LED work. 

The brigness of each LED can be controlled via a PWM (Pulse Widht Modulation), enabling variations of light intensity on each LED which then creates different colors. The following figure ilustrates the I/O interface of the circuit we are going to design. 


                      _______________               
                     |               |          
        clk----------|               |----PWM0      
        rst_n--------|       RGB     |              
        inc----------|      Mixer    |----PWM1      
        dec----------|               |              
        led[1:0]-----|               |----PWM2      
                     |_______________|              


| Port | Direction | Descriptiom |
|------|-----------|-------------|
|clk|input|Clock signal|
|rst_n|input|Async reset|
|inc|input|Increase the Led brightness|
|dec|input|Decrease the Led brightness|
|led[1:0]|input|LED selection|
|PWM0|output|PWM for RED LED|
|PWM1|output|PWM for GREEN LED|
|PWM2|output|PWM for BLUE LED|
||||

- The `led[1:0]` is used to select the LED color to be configured.

- The `inc` and `dec` ports are connected to push buttons. The `inc` input increases the brightness while the `dec` input decreases the brightness of the selected LED.

The following figure depicts the general architecture for the PWM mixer proposed in this tutorial. The necesary modules are a PWM generator, an Up/Down counter to control the birghtness of each LED. Also, each push button for `inc` and `dec` it is necesary to implement a `debounce`and `edge-detector` modules to filter the mechanical noise produced by the push buttons. 

Finally, a 2:4 decoder is used to select a single PWM channel to be configured.

<div style="text-align: center;">
    <img src="./doc/PWM1.svg" width="800" >
</div>

### PWM Core Design

The generation of a PWM signal requires a baseline Sawtooth waveform as shown in the next figure. This signal determines the period of the PWM signal. The final PWM signal is generated by setting a threshold value use to be compare with the sawtooth wave. The operation is quite simple; when the sawtooth wave is below the threshold (e.g., Red line) the output takes a fixed high digital value. On the other hand, when the sawtooth wave goes higer than the threshold line, the output signal goes low. In the end, moving the threshold upwards the pulse widht augments while droping the treshold dowm causes a reduction on the Pulse width of the output signal. 

<div style="text-align: center;">
    <img src="./doc/Wave1.svg" width="800" >
</div>
<div style="text-align: center;">
    <img src="./doc/PWM_Wave.svg" width="800" >
</div>


This PWM generation can be implemented digitally by the digital design shown in the following figure. The Sawtooth can be digitally generated using a counter. The Frequency of the generated waveform $F_{pwm}$ can be ddetermined by the clock reference period times the number of clock cycles elapsed (i.e., PERIOD_VAL). The following expressions describe the way we can set an specific $F_{pwm}$ based on an input $F_{clk}$, calculating the PERIOD_VAT at which we shoudl to restart the counter.

$\frac{1}{F_{pwm}}=\frac{1}{F_{clk}}\times NumClockCycles$

$NumClockCycles=\frac{F_{clk}}{F_{pwm}}=PERIOD\_VAL$

Once implemented the sawtooth generator, the PWM signal is simply generated by comparing the value of the counter and a threshold value (i.e., pwm_ref). This signal can be controlled externally by another component in the system. Finally, the comparison output is regitered by a flipflop in order to remove any possible glitch generation comming from the combinational logic. 


<div style="text-align: center;">
    <img src="./doc/PWMCore.svg" width="800" >
</div>

### UP/Down counter 

This counter helps to set the threshold values used to control the PWM generation. The counter changes up or down only when the global enable signal `enable` is active, otherwishe the counter remians unchaged regardless the states in `inc` and `dec`. During the operation, the `inc` and `dec` inputs must be a single pulse. 

<div style="text-align: center;">
    <img src="./doc/UP-DWN-COre.svg" width="800" >
</div>

### Edge detector

This circuit generarates a single pulse every falling edge detected at the input signal, as required by the up/down counter. The following figures show the waveform and the circuit implemementation for the edge detector. It is worth to mention that in this example we selected falling-edge detection, as most of the push buttons in most of the development boards use the pull-up configuration, chaning from `High` to `Low` when pushing the button. 

<div style="text-align: center;">
    <img src="./doc/EdgeWave.svg" width="800" >
</div>

<div style="text-align: center;">
    <img src="./doc/EdgeCore.svg" width="800" >
</div>

### Debounce circuit

The debounce circuit is fundamental when dealing with mechanical user interfaces (i.e., push buttons, slide switches etc.). In fact, these types of devices are not able of providing clean digital signals; intead, when pressed a mechanical effect produces certain oscilations on the electrical signals. Such oscilations, when not filtered out, can produce unintended, or wrong behaviours on our digital systems. For example, a counter connected to a push button can change more than once on a single push. 


Deboucing the input digital signals require to ensure that they are stable during at least 100ms. This can be achieved using the following circuit design. In the first place a counter with periodical reboot can be used as `strobe` generator, enabling the capture of the input at certain samplig frequency. The every sampled value is pushed into a SIPO (Serial Input Parallel Output) register. The content in the SIPO register can be used to determine whether the input pin shows an stable value or not. 

<div style="text-align: center;">
    <img src="./doc/DebouceCore.svg" width="800" >
</div>

## RGB mixer in Verilog

### PWM Generator 


```verilog
// PWM core description
`timescale 1ns / 1ps
`define CLK_FREQ 50000000
`define CLK_PWM 10000
`define PERIOD_VAL  `CLK_FREQ/`CLK_PWM

module PWM(clk, rst_n, pwm_ref, pwm);
input clk;
input rst_n;
input [$clog2(`PERIOD_VAL)-1:0] pwm_ref;
output pwm;


reg [31:0] counter;
reg pwm_reg;


always @(posedge clk, negedge rst_n) begin
    if (!rst_n) begin
        counter <= 0;
    end else begin
        if ((counter==`PERIOD_VAL)) begin
            counter <= 0;
        end else begin
            counter <= counter + 1;
        end 
    end 
end

always @(posedge clk, negedge rst_n) begin
    if (!rst_n) begin
        pwm_reg <= 0;
    end else begin
        if (counter<pwm_ref) begin
            pwm_reg <= 1'b1;
        end else begin
            pwm_reg <= 1'b0;
        end 
    end 
end 

assign pwm = pwm_reg;
endmodule
```

The following is the Test bench used to simulate the PWM core
```verilog
// PWM TestBench description
`timescale 1ns / 1ps
`define CLK_FREQ 50000000
`define CLK_PWM 10000
`define PERIOD_VAL  `CLK_FREQ/`CLK_PWM

module tb_PWM;

reg s_clk, s_rst_n;
reg [$clog2(`PERIOD_VAL)-1:0] s_pwm_ref;
wire s_pwm;

PWM dut(
.clk(s_clk),
.rst_n(s_rst_n),
.pwm_ref(s_pwm_ref),
.pwm(s_pwm)
);


always begin
    #10 s_clk = ~s_clk;
end


initial
  begin
    $dumpfile("tb_PWM.vcd");
    $dumpvars;
  end

initial begin
s_clk=0;
s_rst_n=0;
s_pwm_ref=100;
#80 s_rst_n=1;
repeat (20000) @(negedge s_clk);
s_pwm_ref=500;
repeat (20000) @(negedge s_clk);
s_pwm_ref=1000;
repeat (20000) @(negedge s_clk);
s_pwm_ref=1500;
repeat (20000) @(negedge s_clk);
s_pwm_ref=2000;
repeat (20000) @(negedge s_clk);
s_pwm_ref=2500;
repeat (20000) @(negedge s_clk);
s_pwm_ref=3000;
repeat (20000) @(negedge s_clk);
s_pwm_ref=4000;
repeat (20000) @(negedge s_clk);
s_pwm_ref=3000;
repeat (20000) @(negedge s_clk);
s_pwm_ref=2500;
repeat (20000) @(negedge s_clk);
s_pwm_ref=2000;
repeat (20000) @(negedge s_clk);
s_pwm_ref=1000;
repeat (20000) @(negedge s_clk);
s_pwm_ref=100;
repeat (20000) @(negedge s_clk);
$finish;
end

endmodule
```

The following commands are used to simulate the verilog design using icarus Verilog.
```bash
iverilog -o tb_PWM.vvp PWM.v tb_PWM.v 
vvp tb_PWM.vvp
gtkwave tb_PWM.vcd
```

Alternativelly, using the following commands you can use `Verilator` to simulate the verilog design.

```bash
verilator --trace --timing --binary -Wno-moddup -Wno-fatal PWM.v tb_PWM.v -top-module tb_PWM
./obj_dir/Vtb_PWM
gtkwave tb_PWM.vcd
```